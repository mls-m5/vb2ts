var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var TokenType;
(function (TokenType) {
    TokenType[TokenType["None"] = 0] = "None";
    TokenType[TokenType["Word"] = 1] = "Word";
    TokenType[TokenType["Digit"] = 2] = "Digit";
    TokenType[TokenType["Operator"] = 3] = "Operator";
    TokenType[TokenType["Line"] = 4] = "Line";
    TokenType[TokenType["Paranthesis"] = 5] = "Paranthesis";
    TokenType[TokenType["Brackets"] = 6] = "Brackets";
    TokenType[TokenType["Braces"] = 7] = "Braces";
    TokenType[TokenType["VariableDeclaration"] = 8] = "VariableDeclaration";
    TokenType[TokenType["PrivateDefinition"] = 9] = "PrivateDefinition";
    TokenType[TokenType["ScopeDeclaration"] = 10] = "ScopeDeclaration";
    TokenType[TokenType["FunctionKeyword"] = 11] = "FunctionKeyword";
    TokenType[TokenType["MethodKeyword"] = 12] = "MethodKeyword";
    TokenType[TokenType["LoopKeyword"] = 13] = "LoopKeyword";
    TokenType[TokenType["ToKeyword"] = 14] = "ToKeyword";
    TokenType[TokenType["EndKeyword"] = 15] = "EndKeyword";
    TokenType[TokenType["AsKeyword"] = 16] = "AsKeyword";
    TokenType[TokenType["IfKeyword"] = 17] = "IfKeyword";
    TokenType[TokenType["ThenKeyword"] = 18] = "ThenKeyword";
    TokenType[TokenType["ElseKeyword"] = 19] = "ElseKeyword";
    TokenType[TokenType["EqualOperator"] = 20] = "EqualOperator";
    TokenType[TokenType["NotKeyword"] = 21] = "NotKeyword";
    TokenType[TokenType["SetKeyword"] = 22] = "SetKeyword";
    TokenType[TokenType["NewKeyword"] = 23] = "NewKeyword";
    TokenType[TokenType["RedimKeyword"] = 24] = "RedimKeyword";
    TokenType[TokenType["WithKeyword"] = 25] = "WithKeyword";
    TokenType[TokenType["ParanthesisGroup"] = 26] = "ParanthesisGroup";
    TokenType[TokenType["FunctionArguments"] = 27] = "FunctionArguments";
    TokenType[TokenType["Condition"] = 28] = "Condition";
    TokenType[TokenType["FunctionDeclaration"] = 29] = "FunctionDeclaration";
    TokenType[TokenType["Assignment"] = 30] = "Assignment";
    TokenType[TokenType["AssignmentTarget"] = 31] = "AssignmentTarget";
    TokenType[TokenType["MethodArguments"] = 32] = "MethodArguments";
    TokenType[TokenType["Loop"] = 33] = "Loop";
    TokenType[TokenType["EndStatement"] = 34] = "EndStatement";
    TokenType[TokenType["IfStatement"] = 35] = "IfStatement";
    TokenType[TokenType["ElseStatement"] = 36] = "ElseStatement";
    TokenType[TokenType["MethodCall"] = 37] = "MethodCall";
    TokenType[TokenType["DeclarationType"] = 38] = "DeclarationType";
    TokenType[TokenType["DeclarationName"] = 39] = "DeclarationName";
    TokenType[TokenType["WithStatement"] = 40] = "WithStatement";
    TokenType[TokenType["WithTarget"] = 41] = "WithTarget";
    //Name of higher analysis
    TokenType[TokenType["FunctionName"] = 42] = "FunctionName";
    TokenType[TokenType["VariableName"] = 43] = "VariableName";
})(TokenType || (TokenType = {}));
//Lowercase because they are compared in lowercase
var ScopeTypes = Object.freeze({
    dim: 0,
    private: 1,
    public: 2,
    protected: 3,
    static: 4
});
var LoopTypes = Object.freeze({
    "for": 0,
    "while": 1
});
var Keywords = Object.freeze({
    as: TokenType.AsKeyword,
    to: TokenType.ToKeyword,
    sub: TokenType.MethodKeyword,
    function: TokenType.FunctionKeyword,
    end: TokenType.EndKeyword,
    if: TokenType.IfKeyword,
    then: TokenType.ThenKeyword,
    else: TokenType.ElseKeyword,
    "=": TokenType.EqualOperator,
    not: TokenType.NotKeyword,
    set: TokenType.SetKeyword,
    new: TokenType.NewKeyword,
    redim: TokenType.RedimKeyword,
    with: TokenType.WithKeyword
});
var BlockType;
(function (BlockType) {
    BlockType[BlockType["Class"] = 0] = "Class";
    BlockType[BlockType["Function"] = 1] = "Function";
    BlockType[BlockType["Module"] = 2] = "Module";
})(BlockType || (BlockType = {}));
var CodeContext = (function () {
    function CodeContext(type) {
        this.type = type;
    }
    return CodeContext;
}());
var classContext = new CodeContext(BlockType.Class);
var functionContext = new CodeContext(BlockType.Function);
var moduleContext = new CodeContext(BlockType.Module);
var Token = (function () {
    function Token() {
        this.type = TokenType.Word;
        this.textAfter = "";
        this.text = "";
        this.rawText = ""; //With cases kept
        this.hasNewline = false;
        this.row = 0;
        this.col = 0;
        this.isStatement = false;
    }
    Token.prototype.statement = function () {
        if (this.isStatement) {
            return this;
        }
        else {
            return null;
        }
    };
    Token.prototype.setText = function (text) {
        this.rawText = text;
        this.text = text.toLowerCase();
    };
    Token.prototype.getText = function () {
        var text = this.rawText;
        if (this.type && this.type != TokenType.Word) {
            text = "[" + TokenType[this.type] + "] " + text;
        }
        if (this.hasNewline) {
            text += "‚èé";
        }
        return text;
    };
    Token.prototype.wrap = function (text) {
        return this.textBefore + text + this.textAfter;
    };
    Token.prototype.toString = function () {
        switch (this.type) {
            case TokenType.NewKeyword:
                return this.wrap(this.text);
            default:
                // if (this.text == ".") {
                // 	return this.wrap("_with_tmp" + this.text);
                // }
                return this.wrap(this.rawText);
                ;
        }
    };
    return Token;
}());
var Statement = (function (_super) {
    __extends(Statement, _super);
    function Statement(statement) {
        _super.call(this);
        this.isStatement = true;
        this.tokens = [];
        if (statement) {
            this.tokens = statement.tokens;
            this.isStatement = statement.isStatement;
        }
    }
    Statement.prototype.getByType = function (type) {
        for (var _i = 0, _a = this.tokens; _i < _a.length; _i++) {
            var t = _a[_i];
            if (t.type == type) {
                return t;
            }
        }
        return null;
    };
    Statement.prototype.back = function () {
        return this.tokens[this.tokens.length - 1];
    };
    Statement.prototype.front = function () {
        return this.tokens[0];
    };
    Statement.prototype.getBefore = function () {
        return this.front().textBefore;
    };
    Statement.prototype.getAfter = function () {
        return this.back().textAfter;
    };
    Statement.prototype.wrap = function (text) {
        return this.getBefore() + text + this.getAfter();
    };
    Statement.prototype.toString = function () {
        var text = "";
        switch (this.type) {
            case TokenType.EndStatement:
                return this.wrap("}");
            case TokenType.IfStatement:
                return this.getBefore() + "if (" + this.getByType(TokenType.Condition) + ")" + this.getAfter();
            case TokenType.ElseStatement:
                return this.getBefore() + "else {" + this.getAfter();
            case TokenType.VariableDeclaration:
                return this.getBefore() + this.getByType(TokenType.DeclarationName).toString() + ": " + this.getByType(TokenType.DeclarationType) + this.getAfter();
            case TokenType.FunctionDeclaration:
                return this.front().textBefore + this.getByType(TokenType.FunctionName) + "" + this.getByType(TokenType.FunctionArguments).toString() + " {" + this.back().textAfter;
            case TokenType.WithStatement:
                return this.wrap("{ let _with_tmp = " + this.getByType(TokenType.WithTarget) + ";");
            default:
                break;
        }
        for (var _i = 0, _a = this.tokens; _i < _a.length; _i++) {
            var s = _a[_i];
            text += s.toString();
        }
        return text;
    };
    return Statement;
}(Token));
// class VariableDeclaration extends Statement {
// 	type = TokenType.VariableDeclaration;
// 	scope: Token;
// 	constructor(statement: Statement) {
// 		super(statement);
// 	}
// 	toString() {
// 		return this.getBefore() + this.getByType(TokenType.DeclarationName).toString() + ": " + this.getByType(TokenType.DeclarationType) + this.getAfter();
// 	}
// }
// class FunctionDeclaration extends Statement {
// 	type = TokenType.FunctionDeclaration;
// 	scope: Token;
// 	constructor(statement: Statement) {
// 		super(statement);
// 	}
// 	toString() {
// 		//Todo: Add arguments
// 		return this.front().textBefore + this.getByType(TokenType.FunctionName) + "" + this.getByType(TokenType.FunctionArguments).toString() + " {" + this.back().textAfter;
// 	}
// }
var TokenizerState;
(function (TokenizerState) {
    TokenizerState[TokenizerState["None"] = 0] = "None";
    TokenizerState[TokenizerState["Word"] = 1] = "Word";
    TokenizerState[TokenizerState["Space"] = 2] = "Space";
    TokenizerState[TokenizerState["Digit"] = 3] = "Digit";
    TokenizerState[TokenizerState["Operators"] = 4] = "Operators";
    TokenizerState[TokenizerState["Paranthesis"] = 5] = "Paranthesis";
})(TokenizerState || (TokenizerState = {}));
;
var operators = "+-*/^.><="; //Different special characters
var paranthesis = "()[]";
function setKeywordType(token) {
    for (var scopeType in ScopeTypes) {
        if (token.text == scopeType) {
            token.type = TokenType.ScopeDeclaration;
            token.specifier = ScopeTypes[scopeType];
            return;
        }
    }
    for (var loopType in LoopTypes) {
        if (token.text == loopType) {
            token.type = TokenType.LoopKeyword;
            token.specifier = LoopTypes[loopType];
            return;
        }
    }
    var type = Keywords[token.text];
    if (type) {
        token.type = type;
        return;
    }
    var firstCharacter = token.text[0];
    if (token.text.length > 0) {
        if (isDigit(firstCharacter)) {
            token.type = TokenType.Digit;
            return;
        }
        else if (token.text.length > 1 && firstCharacter == "." &&
            isDigit(token.text[1])) {
            token.type = TokenType.Digit;
            return;
        }
    }
    if (operators.indexOf(firstCharacter) >= 0) {
        token.type = TokenType.Operator;
        if (token.text == "=") {
            token.type = TokenType.EqualOperator;
        }
    }
}
function isDigit(character) {
    return !isNaN(parseInt(character));
}
var Tokenizer = (function () {
    function Tokenizer() {
    }
    Tokenizer.prototype.tokenize = function (text) {
        var state = TokenizerState.Space;
        var tokens = [];
        var textBefore = "";
        var tokenText = "";
        var textAfter = "";
        var row = 1;
        var col = 1;
        var pushToken = function () {
            var token = new Token();
            token.textBefore = textBefore;
            token.textAfter = textAfter;
            token.setText(tokenText);
            setKeywordType(token);
            tokens.push(token);
            textBefore = "";
            textAfter = "";
            tokenText = "";
            state = TokenizerState.None;
            return token;
        };
        var getBackToken = function () {
            return tokens[tokens.length - 1];
        };
        for (var i = 0; i < text.length; ++i) {
            var c = text[i];
            switch (c) {
                case "\n":
                    if (tokenText.length > 0) {
                        textAfter += c;
                        pushToken();
                        getBackToken().hasNewline = true;
                        row++;
                        col = 1;
                    }
                case " ":
                case "\t":
                    if (tokenText.length > 0) {
                        textAfter += c;
                    }
                    else {
                        textBefore += c;
                    }
                    break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                case ".":
                    if (state = TokenizerState.Word) {
                    }
                    else {
                        if (textAfter.length > 0) {
                            pushToken();
                        }
                        if (state != TokenizerState.Digit && state != TokenizerState.Word && tokenText.length > 0) {
                            pushToken();
                        }
                        var ti = i;
                        while (isDigit(c) || c == ".") {
                            tokenText += c;
                            ++col;
                            ++ti;
                            c = text[ti];
                        }
                        i = ti - 1;
                        // let nType = state == TokenizerState.Digit? TokenType.Digit: TokenType.Word;
                        // pushToken().type = nType;
                        continue; //Skip to the next iteration
                    }
                default:
                    //Se if there is any token to flush
                    if (textAfter.length > 0) {
                        pushToken();
                    }
                    //Then continue with the current token
                    if (operators.indexOf(c) >= 0 || paranthesis.indexOf(c) >= 0) {
                        if (tokenText.length > 0) {
                            pushToken();
                        }
                        tokenText += c;
                        state = TokenizerState.Operators;
                    }
                    else {
                        //This is to make sure that the last spaces/newlines will follow the token
                        if (state == TokenizerState.Operators) {
                            pushToken().type = TokenType.Operator;
                        }
                        state == TokenizerState.Word;
                        tokenText += c;
                    }
                    break;
            }
            ++col;
        }
        if (tokenText.length > 0) {
            pushToken();
        }
        return tokens;
    };
    return Tokenizer;
}());
/// <reference path="tokenizer.ts" />
var Interpreter = (function () {
    function Interpreter() {
    }
    Interpreter.prototype.processStatement = function (statement) {
        if (statement.isStatement) {
            var tokens = statement.tokens;
            //First group by paranthesis
            for (var i = tokens.length - 1; i >= 0; --i) {
                if (tokens[i].text == "(") {
                    for (var j = i + 1; j < tokens.length; ++j) {
                        if (tokens[j].text == ")") {
                            var group = new Statement();
                            group.type = TokenType.ParanthesisGroup;
                            group.tokens = tokens.splice(i, j - i + 1, group);
                            break;
                        }
                    }
                }
            }
            for (var i = 0; i < tokens.length; ++i) {
                if (tokens[i].type == TokenType.AsKeyword && statement.tokens.length > (i + 1)) {
                    tokens[i + 1].type = TokenType.DeclarationType;
                    if (i > 0 && tokens[i - 1].type == TokenType.Word) {
                        tokens[i - 1].type = TokenType.DeclarationName;
                    }
                }
            }
            var first = statement.tokens[0];
            //Checking for variable declarations
            if (first.type == TokenType.ScopeDeclaration) {
                // statement = new VariableDeclaration(statement);
                statement.type = TokenType.VariableDeclaration;
                if (statement.tokens.length > 1) {
                    var t = statement.tokens[1];
                    if (t.type == TokenType.FunctionKeyword || t.type == TokenType.MethodKeyword) {
                        // statement = new FunctionDeclaration(statement);
                        statement.type = TokenType.FunctionDeclaration;
                        statement.tokens[2].type = TokenType.FunctionName;
                        if (tokens[3].type == TokenType.ParanthesisGroup) {
                            tokens[3].type = TokenType.FunctionArguments;
                        }
                    }
                }
            }
            else if (first.type == TokenType.WithKeyword) {
                statement.type = TokenType.WithStatement;
                tokens[1].type = TokenType.WithTarget;
            }
            else if (first.type == TokenType.EndKeyword) {
                statement.type = TokenType.EndStatement;
            }
            else if (first.type == TokenType.ElseKeyword) {
                statement.type = TokenType.ElseStatement;
            }
            else if (first.type == Keywords.set) {
                statement.type = TokenType.Assignment;
                statement.tokens[1].type = TokenType.AssignmentTarget;
            }
            else if (first.text == "for") {
                statement.type = TokenType.Loop;
            }
            else if (first.type == TokenType.Word && statement.tokens.length > 1 &&
                (statement.tokens[1].type == TokenType.Word || statement.tokens[1].type == TokenType.Digit)) {
                statement.type = TokenType.MethodCall;
                first.type = TokenType.FunctionName;
                var args = new Statement();
                args.type = TokenType.MethodArguments;
                args.tokens = statement.tokens.splice(1, statement.tokens.length - 1, args);
            }
            else if (first.type == TokenType.IfKeyword) {
                statement.type = TokenType.IfStatement;
                for (var i = 1; i < statement.tokens.length; ++i) {
                    if (statement.tokens[i].type == TokenType.ThenKeyword) {
                        var condition = new Statement();
                        condition.type = TokenType.Condition;
                        condition.tokens = statement.tokens.splice(1, i - 1, condition);
                        break;
                    }
                }
            }
            else if (statement.tokens.length > 3 && statement.type != TokenType.Condition && statement.getByType(TokenType.EqualOperator)) {
                statement.type = TokenType.Assignment;
            }
        }
        return statement;
    };
    Interpreter.prototype.group = function (tokens) {
        var currentStatement = new Statement();
        var statements = [];
        for (var i in tokens) {
            var t = tokens[i];
            currentStatement.type = TokenType.Line;
            currentStatement.tokens.push(t);
            if (t.hasNewline) {
                currentStatement.textAfter = t.textAfter;
                currentStatement.hasNewline = true;
                t.textAfter = "";
                t.hasNewline = false;
                // try {
                currentStatement = this.processStatement(currentStatement); //Process the statement
                // } catch(e) {
                // console.error(e);
                // }
                statements.push(currentStatement);
                currentStatement = new Statement();
            }
        }
        if (currentStatement.tokens.length > 0) {
            statements.push(currentStatement);
        }
        return statements;
    };
    return Interpreter;
}());
/// <reference path="jquery.d.ts" />
/// <reference path="interpreter.ts" />
$(document).ready(function () {
    var tokenizer = new Tokenizer();
    var interpreter = new Interpreter();
    var $vb_text = $("#vb_text");
    var $ts_text = $("#ts_text");
    var $structure_view = $("#structure_view");
    $vb_text.on("change keyup paste", function () {
        var tokens = tokenizer.tokenize($vb_text.val());
        var statements = interpreter.group(tokens);
        var output = "";
        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
            var s = statements_1[_i];
            try {
                output += s.toString() + " ";
            }
            catch (e) {
                console.error(e);
            }
        }
        var wrap = function (text) {
            return '<div class="token">' + text + '</div>';
        };
        var drawStatement = function (statement) {
            if (statement.isStatement) {
                var out = statement.getText() + ": ";
                for (var _i = 0, _a = statement.statement().tokens; _i < _a.length; _i++) {
                    var s = _a[_i];
                    out += drawStatement(s);
                }
                return wrap(out);
            }
            else {
                return wrap(statement.getText());
            }
        };
        $ts_text.val(output);
        var out2 = "";
        for (var _a = 0, statements_2 = statements; _a < statements_2.length; _a++) {
            var s = statements_2[_a];
            try {
                out2 += drawStatement(s) + "<br>";
            }
            catch (e) {
                console.error(e);
            }
        }
        $structure_view.html(out2);
    });
});
