/// <reference path="interpreter.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var TokenType;
(function (TokenType) {
    TokenType[TokenType["None"] = 0] = "None";
    TokenType[TokenType["Word"] = 1] = "Word";
    TokenType[TokenType["Digit"] = 2] = "Digit";
    TokenType[TokenType["Operator"] = 3] = "Operator";
    TokenType[TokenType["Line"] = 4] = "Line";
    TokenType[TokenType["Paranthesis"] = 5] = "Paranthesis";
    TokenType[TokenType["Brackets"] = 6] = "Brackets";
    TokenType[TokenType["Braces"] = 7] = "Braces";
    TokenType[TokenType["VariableDeclaration"] = 8] = "VariableDeclaration";
    TokenType[TokenType["PrivateDefinition"] = 9] = "PrivateDefinition";
    TokenType[TokenType["ScopeDeclaration"] = 10] = "ScopeDeclaration";
    TokenType[TokenType["FunctionKeyword"] = 11] = "FunctionKeyword";
    TokenType[TokenType["MethodKeyword"] = 12] = "MethodKeyword";
    TokenType[TokenType["LoopKeyword"] = 13] = "LoopKeyword";
    TokenType[TokenType["ToKeyword"] = 14] = "ToKeyword";
    TokenType[TokenType["EndKeyword"] = 15] = "EndKeyword";
    TokenType[TokenType["AsKeyword"] = 16] = "AsKeyword";
    TokenType[TokenType["IfKeyword"] = 17] = "IfKeyword";
    TokenType[TokenType["ThenKeyword"] = 18] = "ThenKeyword";
    TokenType[TokenType["ElseKeyword"] = 19] = "ElseKeyword";
    TokenType[TokenType["EqualOperator"] = 20] = "EqualOperator";
    TokenType[TokenType["NotKeyword"] = 21] = "NotKeyword";
    TokenType[TokenType["SetKeyword"] = 22] = "SetKeyword";
    TokenType[TokenType["NewKeyword"] = 23] = "NewKeyword";
    TokenType[TokenType["RedimKeyword"] = 24] = "RedimKeyword";
    TokenType[TokenType["WithKeyword"] = 25] = "WithKeyword";
    TokenType[TokenType["Coma"] = 26] = "Coma";
    TokenType[TokenType["ExitKeyword"] = 27] = "ExitKeyword";
    TokenType[TokenType["OptionKeyword"] = 28] = "OptionKeyword";
    TokenType[TokenType["ExplicitKeyword"] = 29] = "ExplicitKeyword";
    TokenType[TokenType["StepKeyword"] = 30] = "StepKeyword";
    TokenType[TokenType["NextKeyword"] = 31] = "NextKeyword";
    TokenType[TokenType["CommentKeyword"] = 32] = "CommentKeyword";
    TokenType[TokenType["VariableDeclarationGroup"] = 33] = "VariableDeclarationGroup";
    TokenType[TokenType["ParanthesisGroup"] = 34] = "ParanthesisGroup";
    TokenType[TokenType["FunctionArguments"] = 35] = "FunctionArguments";
    TokenType[TokenType["Condition"] = 36] = "Condition";
    TokenType[TokenType["FunctionDeclaration"] = 37] = "FunctionDeclaration";
    TokenType[TokenType["Assignment"] = 38] = "Assignment";
    TokenType[TokenType["AssignmentTarget"] = 39] = "AssignmentTarget";
    TokenType[TokenType["MethodArguments"] = 40] = "MethodArguments";
    TokenType[TokenType["ForLoop"] = 41] = "ForLoop";
    TokenType[TokenType["EndStatement"] = 42] = "EndStatement";
    TokenType[TokenType["IfStatement"] = 43] = "IfStatement";
    TokenType[TokenType["ElseStatement"] = 44] = "ElseStatement";
    TokenType[TokenType["MethodCall"] = 45] = "MethodCall";
    TokenType[TokenType["DeclarationType"] = 46] = "DeclarationType";
    TokenType[TokenType["DeclarationName"] = 47] = "DeclarationName";
    TokenType[TokenType["WithStatement"] = 48] = "WithStatement";
    TokenType[TokenType["WithTarget"] = 49] = "WithTarget";
    TokenType[TokenType["MemberName"] = 50] = "MemberName";
    TokenType[TokenType["MemberNameGroup"] = 51] = "MemberNameGroup";
    TokenType[TokenType["WithMemberGroup"] = 52] = "WithMemberGroup";
    TokenType[TokenType["DeclarationSeparator"] = 53] = "DeclarationSeparator";
    TokenType[TokenType["ExitStatement"] = 54] = "ExitStatement";
    TokenType[TokenType["OptionStatement"] = 55] = "OptionStatement";
    TokenType[TokenType["NextStatement"] = 56] = "NextStatement";
    TokenType[TokenType["CommentStatement"] = 57] = "CommentStatement";
    TokenType[TokenType["ForStart"] = 58] = "ForStart";
    TokenType[TokenType["ForStop"] = 59] = "ForStop";
    TokenType[TokenType["ForStep"] = 60] = "ForStep";
    TokenType[TokenType["ForVariableName"] = 61] = "ForVariableName";
    //Name of higher analysis
    TokenType[TokenType["FunctionName"] = 62] = "FunctionName";
    TokenType[TokenType["VariableName"] = 63] = "VariableName";
})(TokenType || (TokenType = {}));
//Lowercase because they are compared in lowercase
var ScopeTypes = Object.freeze({
    dim: 0,
    private: 1,
    public: 2,
    protected: 3,
    static: 4
});
var LoopTypes = Object.freeze({
    "for": 0,
    "while": 1
});
function isNumeric(num) {
    return !isNaN(num);
}
var Keywords = Object.freeze({
    as: TokenType.AsKeyword,
    to: TokenType.ToKeyword,
    sub: TokenType.MethodKeyword,
    function: TokenType.FunctionKeyword,
    end: TokenType.EndKeyword,
    if: TokenType.IfKeyword,
    then: TokenType.ThenKeyword,
    else: TokenType.ElseKeyword,
    "=": TokenType.EqualOperator,
    not: TokenType.NotKeyword,
    set: TokenType.SetKeyword,
    new: TokenType.NewKeyword,
    redim: TokenType.RedimKeyword,
    with: TokenType.WithKeyword,
    ",": TokenType.Coma,
    exit: TokenType.ExitKeyword,
    option: TokenType.OptionKeyword,
    explicit: TokenType.ExplicitKeyword,
    step: TokenType.StepKeyword,
    next: TokenType.NextKeyword,
    "'": TokenType.CommentKeyword
});
var shorthandVariableTypes = Object.freeze({
    "%": "Integer",
    "&": "Long",
    "@": "Decimal",
    "!": "Single",
    "#": "Double",
    "$": "String"
});
var typeTranslation = Object.freeze({
    "integer": "number",
    "long": "number",
    "decimal": "number",
    "single": "number",
    "double": "number",
    "string": "string",
    "boolean": "boolean",
    "byte": "number",
    "%": "number",
    "&": "number",
    "@": "number",
    "!": "number",
    "#": "number",
    "$": "string"
});
function isShorthandSign(c) {
    return typeof shorthandVariableTypes[c] !== 'undefined';
}
var BlockType;
(function (BlockType) {
    BlockType[BlockType["Class"] = 0] = "Class";
    BlockType[BlockType["Function"] = 1] = "Function";
    BlockType[BlockType["Module"] = 2] = "Module";
})(BlockType || (BlockType = {}));
var CodeContext = (function () {
    function CodeContext(type) {
        this.type = type;
    }
    return CodeContext;
}());
var classContext = new CodeContext(BlockType.Class);
var functionContext = new CodeContext(BlockType.Function);
var moduleContext = new CodeContext(BlockType.Module);
var Token = (function () {
    function Token(type) {
        if (type === void 0) { type = TokenType.Word; }
        this.type = type;
        this.textAfter = "";
        this.text = "";
        this.rawText = ""; //With cases kept
        this.hasNewline = false;
        this.row = 0;
        this.col = 0;
        this.isStatement = false;
    }
    Token.prototype.statement = function () {
        if (this.isStatement) {
            return this;
        }
        else {
            return null;
        }
    };
    Token.prototype.setText = function (text) {
        this.rawText = text;
        this.text = text.toLowerCase();
    };
    Token.prototype.getText = function () {
        var text = this.rawText;
        if (this.type && this.type != TokenType.Word) {
            text = "[" + TokenType[this.type] + "] " + text;
        }
        if (this.hasNewline) {
            text += "‚èé";
        }
        return text;
    };
    Token.prototype.wrap = function (text) {
        return this.textBefore + text + this.textAfter;
    };
    Token.prototype.toString = function () {
        switch (this.type) {
            case TokenType.NewKeyword:
                return this.wrap(this.text);
            case TokenType.ScopeDeclaration:
                if (this.specifier == ScopeTypes.static) {
                    return this.wrap("// Static type not supported implement in other way : ");
                }
                else if (interpreterContext.currentScope == ScopeType.Class) {
                    return this.textBefore;
                }
                else {
                    return this.wrap("let");
                }
            case TokenType.CommentKeyword:
                return this.wrap("//");
            case TokenType.NotKeyword:
                return this.textBefore + "!";
            case TokenType.SetKeyword:
                return this.wrap(""); //Hide the keyword, it is not the same in javascript
            case TokenType.DeclarationType:
                var t = typeTranslation[this.text];
                if (t) {
                    return this.wrap(t);
                }
                else {
                    return this.wrap(this.rawText);
                }
            case TokenType.DeclarationSeparator:
                if (interpreterContext.currentScope == ScopeType.Class) {
                    return this.wrap(";");
                }
                else
                    return this.wrap(this.rawText);
            case TokenType.Word:
                if (interpreterContext.isClassVariable(this.text)) {
                    return this.wrap("this." + this.rawText);
                }
                else {
                    return this.wrap(this.rawText);
                }
            default:
                // if (this.text == ".") {
                // 	return this.wrap("_with_tmp" + this.text);
                // }
                return this.wrap(this.rawText);
                ;
        }
    };
    return Token;
}());
var Statement = (function (_super) {
    __extends(Statement, _super);
    function Statement(type) {
        if (type === void 0) { type = TokenType.Word; }
        _super.call(this, type);
        this.isStatement = true;
        this.tokens = [];
    }
    Statement.prototype.getByType = function (type) {
        for (var _i = 0, _a = this.tokens; _i < _a.length; _i++) {
            var t = _a[_i];
            if (t.type == type) {
                return t;
            }
        }
        return null;
    };
    Statement.prototype.back = function () {
        return this.tokens[this.tokens.length - 1];
    };
    Statement.prototype.front = function () {
        return this.tokens[0];
    };
    Statement.prototype.getBefore = function () {
        return this.front().textBefore;
    };
    Statement.prototype.getAfter = function () {
        return this.back().textAfter;
    };
    Statement.prototype.wrap = function (text, semicolon) {
        if (semicolon === void 0) { semicolon = false; }
        var colontext = semicolon ? ";" : "";
        return this.getBefore() + text + colontext + this.getAfter();
    };
    Statement.prototype.setTokens = function (tokens) {
        this.tokens = tokens;
        // this.textBefore = this.front().textBefore;
        // this.front().textBefore = "";
        // this.textAfter = this.back().textAfter;
        // this.back().textAfter = "";
    };
    Statement.prototype.toString = function () {
        var text = "";
        switch (this.type) {
            case TokenType.EndStatement:
                interpreterContext.popScope();
                return this.wrap("}");
            case TokenType.IfStatement:
                interpreterContext.pushScope(ScopeType.Function);
                return this.wrap("if (" + this.getByType(TokenType.Condition) + ") {");
            case TokenType.ElseStatement:
                return this.wrap("} else {");
            case TokenType.WithMemberGroup:
                // return this.wrap(interpreterContext.currentWith.toString() + "." + this.getByType(TokenType.MemberName));
                return this.wrap("_with_tmp." + this.getByType(TokenType.MemberName));
            case TokenType.VariableDeclarationGroup:
                var variableNameToken = this.getByType(TokenType.DeclarationName);
                interpreterContext.declareVariable(variableNameToken.text, this);
                var addSemicolon = false; //interpreterContext.currentScope == ScopeType.Class;
                return this.wrap(variableNameToken.rawText + ": " + this.getByType(TokenType.DeclarationType), addSemicolon);
            case TokenType.FunctionDeclaration:
                var functionNameToken = this.getByType(TokenType.FunctionName);
                var functionName = void 0;
                if (functionNameToken.text == "new" || functionNameToken.text == "class_initialize") {
                    functionName = "constructor";
                }
                else {
                    functionName = functionNameToken.rawText;
                }
                interpreterContext.pushScope(ScopeType.ArgumentList);
                var argsString = this.getByType(TokenType.FunctionArguments).toString();
                interpreterContext.setScope(ScopeType.Function);
                return this.wrap(functionName + "" + argsString + " {");
            case TokenType.WithStatement:
                interpreterContext.pushScope(ScopeType.With);
                interpreterContext.currentWith = this.getByType(TokenType.WithTarget);
                return this.wrap("{ let _with_tmp = " + this.getByType(TokenType.WithTarget) + ";");
            case TokenType.MethodCall:
                return this.wrap(this.getByType(TokenType.FunctionName) + "(" + this.getByType(TokenType.MethodArguments) + ")", true);
            case TokenType.ExitStatement:
                return this.wrap("return", true);
            case TokenType.OptionStatement:
                return "";
            case TokenType.ForLoop:
                var varName = this.getByType(TokenType.ForVariableName);
                var start = this.getByType(TokenType.ForStart);
                var stop = this.getByType(TokenType.ForStop);
                var step = this.getByType(TokenType.ForStep);
                var stepString = void 0;
                if (step == null) {
                    stepString = "++" + varName.rawText;
                }
                else {
                    stepString = varName.rawText + " += " + step.rawText;
                }
                interpreterContext.pushScope(ScopeType.Function);
                return this.wrap("for (var " + varName + "= " + start.rawText + "; " + varName + "<= " + stop.rawText + "; " + stepString + ") {");
            case TokenType.NextStatement:
                interpreterContext.popScope(ScopeType.Function);
                return this.wrap("}");
            default:
                break;
        }
        for (var _i = 0, _a = this.tokens; _i < _a.length; _i++) {
            var s = _a[_i];
            text += s.toString();
        }
        //Hack to add semicolon on assignments
        if (this.type == TokenType.Assignment) {
            var i = text.length - this.back().textAfter.length;
            return text.slice(0, i) + ";" + text.slice(i, text.length - i);
        }
        return text;
    };
    return Statement;
}(Token));
var TokenizerState;
(function (TokenizerState) {
    TokenizerState[TokenizerState["None"] = 0] = "None";
    TokenizerState[TokenizerState["Word"] = 1] = "Word";
    TokenizerState[TokenizerState["Space"] = 2] = "Space";
    TokenizerState[TokenizerState["Digit"] = 3] = "Digit";
    TokenizerState[TokenizerState["Operators"] = 4] = "Operators";
    TokenizerState[TokenizerState["Paranthesis"] = 5] = "Paranthesis";
})(TokenizerState || (TokenizerState = {}));
;
var operators = "+-*/'^,.><=%@!#$&"; //Different special characters
var paranthesis = "()[]";
function setKeywordType(token) {
    for (var scopeType in ScopeTypes) {
        if (token.text == scopeType) {
            token.type = TokenType.ScopeDeclaration;
            token.specifier = ScopeTypes[scopeType];
            return;
        }
    }
    for (var loopType in LoopTypes) {
        if (token.text == loopType) {
            token.type = TokenType.LoopKeyword;
            token.specifier = LoopTypes[loopType];
            return;
        }
    }
    var type = Keywords[token.text];
    if (type) {
        token.type = type;
        return;
    }
    var firstCharacter = token.text[0];
    if (token.text.length > 0) {
        if (isDigit(firstCharacter)) {
            token.type = TokenType.Digit;
            return;
        }
        else if (token.text.length > 1 && firstCharacter == "." &&
            isDigit(token.text[1])) {
            token.type = TokenType.Digit;
            return;
        }
    }
    if (operators.indexOf(firstCharacter) >= 0) {
        token.type = TokenType.Operator;
        if (token.text == "=") {
            token.type = TokenType.EqualOperator;
        }
    }
}
function isDigit(character) {
    return !isNaN(parseInt(character));
}
var Tokenizer = (function () {
    function Tokenizer() {
    }
    Tokenizer.prototype.tokenize = function (text) {
        var state = TokenizerState.Space;
        var tokens = [];
        var textBefore = "";
        var tokenText = "";
        var textAfter = "";
        var row = 1;
        var col = 1;
        var pushToken = function () {
            var token = new Token();
            token.textBefore = textBefore;
            token.textAfter = textAfter;
            token.setText(tokenText);
            setKeywordType(token);
            tokens.push(token);
            textBefore = "";
            textAfter = "";
            tokenText = "";
            state = TokenizerState.None;
            return token;
        };
        var getBackToken = function () {
            return tokens[tokens.length - 1];
        };
        for (var i = 0; i < text.length; ++i) {
            var c = text[i];
            switch (c) {
                case "\n":
                    if (tokenText.length > 0) {
                        textAfter += c;
                        pushToken();
                        getBackToken().hasNewline = true;
                        row++;
                        col = 1;
                    }
                case " ":
                case "\t":
                    if (tokenText.length > 0) {
                        textAfter += c;
                    }
                    else {
                        textBefore += c;
                    }
                    break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                case ".":
                    if (state = TokenizerState.Word) {
                    }
                    else {
                        if (textAfter.length > 0) {
                            pushToken();
                        }
                        if (state != TokenizerState.Digit && state != TokenizerState.Word && tokenText.length > 0) {
                            pushToken();
                        }
                        var ti = i;
                        while (isDigit(c) || c == ".") {
                            tokenText += c;
                            ++col;
                            ++ti;
                            c = text[ti];
                        }
                        i = ti - 1;
                        // let nType = state == TokenizerState.Digit? TokenType.Digit: TokenType.Word;
                        // pushToken().type = nType;
                        continue; //Skip to the next iteration
                    }
                default:
                    //Se if there is any token to flush
                    if (textAfter.length > 0) {
                        pushToken();
                    }
                    //Then continue with the current token
                    if (operators.indexOf(c) >= 0 || paranthesis.indexOf(c) >= 0) {
                        if (tokenText.length > 0) {
                            pushToken();
                        }
                        tokenText += c;
                        state = TokenizerState.Operators;
                    }
                    else {
                        //This is to make sure that the last spaces/newlines will follow the token
                        if (state == TokenizerState.Operators) {
                            pushToken().type = TokenType.Operator;
                        }
                        state == TokenizerState.Word;
                        tokenText += c;
                    }
                    break;
            }
            ++col;
        }
        if (tokenText.length > 0) {
            pushToken();
        }
        return tokens;
    };
    return Tokenizer;
}());
/// <reference path="tokenizer.ts" />
var ScopeType;
(function (ScopeType) {
    ScopeType[ScopeType["Function"] = 0] = "Function";
    ScopeType[ScopeType["Class"] = 1] = "Class";
    ScopeType[ScopeType["Global"] = 2] = "Global";
    ScopeType[ScopeType["With"] = 3] = "With";
    ScopeType[ScopeType["ArgumentList"] = 4] = "ArgumentList";
})(ScopeType || (ScopeType = {}));
var InterpreterContext = (function () {
    function InterpreterContext() {
        this.interpreterScopeStack = [];
        this.currentScope = ScopeType.Class;
        this.classVariables = {};
        this.localVariables = {};
    }
    InterpreterContext.prototype.reset = function () {
        this.currentWith = null;
        this.interpreterScopeStack = [];
        this.currentScope = ScopeType.Class;
        this.classVariables = {};
        this.localVariables = {};
    };
    //Change the scope without pushing
    InterpreterContext.prototype.setScope = function (scope) {
        this.currentScope = scope;
    };
    InterpreterContext.prototype.declareVariable = function (name, token) {
        if (this.currentScope == ScopeType.Class) {
            this.classVariables[name] = token;
        }
        else {
            this.localVariables[name] = token;
        }
    };
    InterpreterContext.prototype.pushScope = function (scope) {
        this.interpreterScopeStack.push(this.currentScope);
        this.currentScope = scope;
    };
    InterpreterContext.prototype.isClassVariable = function (name) {
        if (typeof this.classVariables[name] !== 'undefined') {
            if (typeof this.localVariables[name] === 'undefined') {
                return true;
            }
        }
        return false;
    };
    //Pops the last scope and return to previous scope
    //The scope argument is optional, but can be checked
    //so that the right scope is popped
    InterpreterContext.prototype.popScope = function (scope) {
        if (typeof scope === 'undefined') {
            if (this.interpreterScopeStack.length == 0) {
                throw "End statement but no scope to end: scope stack empty";
            }
            this.currentScope = this.interpreterScopeStack.pop();
        }
        else if (scope == this.currentScope) {
            this.currentScope = this.interpreterScopeStack.pop();
        }
        else {
            throw "wrong scope type expected type " + ScopeType[this.currentScope] + " got " + ScopeType[scope];
        }
        //Remove all local variables
        if (this.currentScope == ScopeType.Class) {
            this.localVariables = {};
        }
    };
    return InterpreterContext;
}());
var interpreterContext = new InterpreterContext();
var Interpreter = (function () {
    function Interpreter() {
    }
    Interpreter.prototype.processStatement = function (statement, context) {
        if (context === void 0) { context = new InterpreterContext; }
        if (statement.isStatement) {
            var tokens = statement.tokens;
            for (var i = 0; i < tokens.length; ++i) {
                if (tokens[i].text == "'") {
                    var commentStatement = new Statement(TokenType.CommentStatement);
                    tokens[i].type = TokenType.CommentKeyword;
                    commentStatement.tokens = tokens.splice(i, tokens.length - i, commentStatement);
                    break;
                }
            }
            for (var i = 0; i < tokens.length; ++i) {
                if (tokens[i].type == TokenType.AsKeyword && statement.tokens.length > (i + 1)) {
                    tokens[i + 1].type = TokenType.DeclarationType;
                    if (i > 0 && tokens[i - 1].type == TokenType.Word) {
                        tokens[i - 1].type = TokenType.DeclarationName;
                    }
                }
            }
            //by paranthesis
            for (var i = tokens.length - 1; i >= 0; --i) {
                if (tokens[i].text == "(") {
                    for (var j = i + 1; j < tokens.length; ++j) {
                        if (tokens[j].text == ")") {
                            var group = new Statement();
                            group.type = TokenType.ParanthesisGroup;
                            group.setTokens(tokens.splice(i, j - i + 1, group));
                            break;
                        }
                    }
                }
            }
            for (var i = 0; i < tokens.length - 1; ++i) {
                if (tokens[i].text == "." && tokens[i + 1].type == TokenType.Word) {
                    var group = new Statement();
                    group.type = TokenType.MemberNameGroup;
                    tokens[i + 1].type = TokenType.MemberName;
                    group.setTokens(tokens.splice(i, 2, group));
                }
            }
            //Check how witch statements is ment to be to a With-statement
            //that is if there is no name before the dot
            if (tokens[0].type == TokenType.MemberNameGroup) {
                tokens[0].type = TokenType.WithMemberGroup;
            }
            //The same as above but for the whole statement
            for (var i = 1; i < tokens.length; ++i) {
                if (tokens[i].type == TokenType.MemberNameGroup) {
                    //Todo: Differentiate between ordinary member groups and with groups
                    var tokenBefore = tokens[i - 1];
                    if (tokenBefore.type == TokenType.Operator || tokenBefore.text == "(" || tokenBefore.text == ",") {
                        tokens[i].type = TokenType.WithMemberGroup;
                    }
                }
            }
            var first = statement.tokens[0];
            //Checking for variable declarations
            if (first.type == TokenType.ScopeDeclaration) {
                // statement = new VariableDeclaration(statement);
                statement.type = TokenType.VariableDeclaration;
                if (statement.tokens.length > 1) {
                    var t = statement.tokens[1];
                    if (t.type == TokenType.FunctionKeyword || t.type == TokenType.MethodKeyword) {
                        statement.type = TokenType.FunctionDeclaration;
                        statement.tokens[2].type = TokenType.FunctionName;
                        if (tokens[3].type == TokenType.ParanthesisGroup) {
                            tokens[3].type = TokenType.FunctionArguments;
                        }
                    }
                }
            }
            if (first.type == TokenType.FunctionKeyword || first.type == TokenType.MethodKeyword) {
                statement.type = TokenType.FunctionDeclaration;
                statement.tokens[1].type = TokenType.FunctionName;
                if (tokens[2].type == TokenType.ParanthesisGroup) {
                    tokens[2].type = TokenType.FunctionArguments;
                }
            }
            else if (first.type == TokenType.WithKeyword) {
                statement.type = TokenType.WithStatement;
                tokens[1].type = TokenType.WithTarget;
            }
            else if (first.type == TokenType.EndKeyword) {
                statement.type = TokenType.EndStatement;
            }
            else if (first.type == TokenType.ElseKeyword) {
                statement.type = TokenType.ElseStatement;
            }
            else if (first.type == Keywords.set) {
                statement.type = TokenType.Assignment;
                statement.tokens[1].type = TokenType.AssignmentTarget;
            }
            else if (first.text == "for") {
                statement.type = TokenType.ForLoop;
                tokens[1].type = TokenType.ForVariableName;
                for (var i = 2; i < tokens.length - 1; ++i) {
                    if (tokens[i].type == TokenType.EqualOperator) {
                        tokens[i + 1].type = TokenType.ForStart;
                    }
                    else if (tokens[i].type == TokenType.ToKeyword) {
                        tokens[i + 1].type = TokenType.ForStop;
                    }
                    else if (tokens[i].type == TokenType.StepKeyword) {
                        tokens[i + 1].type = TokenType.ForStep;
                    }
                }
            }
            else if (first.type == TokenType.Word && statement.tokens.length > 1 &&
                (statement.tokens[1].type == TokenType.Word || statement.tokens[1].type == TokenType.Digit)) {
                statement.type = TokenType.MethodCall;
                first.type = TokenType.FunctionName;
                var args = new Statement();
                args.type = TokenType.MethodArguments;
                args.setTokens(statement.tokens.splice(1, statement.tokens.length - 1, args));
            }
            else if (first.type == TokenType.IfKeyword) {
                statement.type = TokenType.IfStatement;
                for (var i = 1; i < statement.tokens.length; ++i) {
                    if (statement.tokens[i].type == TokenType.ThenKeyword) {
                        var condition = new Statement();
                        condition.type = TokenType.Condition;
                        condition.setTokens(statement.tokens.splice(1, i - 1, condition));
                        break;
                    }
                }
            }
            else if (first.type == TokenType.OptionKeyword) {
                statement.type = TokenType.OptionStatement;
            }
            else if (first.type == TokenType.ExitKeyword) {
                statement.type = TokenType.ExitStatement;
            }
            else if (statement.tokens.length > 3 && statement.type != TokenType.Condition && statement.getByType(TokenType.EqualOperator)) {
                statement.type = TokenType.Assignment;
            }
            else if (first.type == TokenType.NextKeyword) {
                statement.type = TokenType.NextStatement;
            }
            var groupDeclarations = function (tokens) {
                for (var i = 1; i < tokens.length - 1; ++i) {
                    if (tokens[i].type == TokenType.AsKeyword) {
                        var group = new Statement();
                        group.type = TokenType.VariableDeclarationGroup;
                        group.setTokens(tokens.splice(i - 1, 3, group));
                    }
                }
                for (var i = 1; i < tokens.length; ++i) {
                    if (isShorthandSign(tokens[i].text)) {
                        var group = new Statement();
                        tokens[i].type = TokenType.DeclarationType;
                        // tokens[i].rawText = shorthandVariableTypes[tokens[i].text]; //Replace the type to the actual type
                        tokens[i - 1].type = TokenType.DeclarationName;
                        group.type = TokenType.VariableDeclarationGroup;
                        group.setTokens(tokens.splice(i - 1, 2, group));
                    }
                }
            };
            if (statement.type == TokenType.FunctionDeclaration) {
                var args = statement.getByType(TokenType.FunctionArguments);
                if (args && args.isStatement) {
                    var argsStatement = args;
                    groupDeclarations(argsStatement.tokens);
                }
            }
            if (statement.type == TokenType.VariableDeclaration) {
                groupDeclarations(tokens);
                for (var i = 1; i < tokens.length - 1; ++i) {
                    if (tokens[i].type == TokenType.Coma) {
                        tokens[i].type = TokenType.DeclarationSeparator;
                    }
                }
            }
        }
        return statement;
    };
    Interpreter.prototype.group = function (tokens) {
        var currentStatement = new Statement();
        var statements = [];
        for (var i in tokens) {
            var t = tokens[i];
            currentStatement.type = TokenType.Line;
            currentStatement.tokens.push(t);
            if (t.hasNewline) {
                currentStatement.textAfter = t.textAfter;
                currentStatement.hasNewline = true;
                t.textAfter = "";
                t.hasNewline = false;
                // try {
                currentStatement = this.processStatement(currentStatement); //Process the statement
                // } catch(e) {
                // console.error(e);
                // }
                statements.push(currentStatement);
                currentStatement = new Statement();
            }
        }
        if (currentStatement.tokens.length > 0) {
            currentStatement = this.processStatement(currentStatement);
            statements.push(currentStatement);
        }
        return statements;
    };
    return Interpreter;
}());
/// <reference path="jquery.d.ts" />
/// <reference path="interpreter.ts" />
$(document).ready(function () {
    var tokenizer = new Tokenizer();
    var interpreter = new Interpreter();
    var $vb_text = $("#vb_text");
    var $ts_text = $("#ts_text");
    var $structure_view = $("#structure_view");
    $vb_text.on("change keyup paste", function () {
        var tokens = tokenizer.tokenize($vb_text.val());
        var statements = interpreter.group(tokens);
        var output = "";
        interpreterContext.reset();
        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
            var s = statements_1[_i];
            try {
                output += s.toString();
            }
            catch (e) {
                console.error(e);
            }
        }
        output = "\t" + output.split("\n").join("\n\t");
        // output = (output.replace("\n", "\n\t"));
        output = "class xx { \n " + output + "\n}";
        var wrap = function (text) {
            return '<div class="token">' + text + '</div>';
        };
        var drawStatement = function (statement) {
            if (statement.isStatement) {
                var out = statement.getText() + ": ";
                for (var _i = 0, _a = statement.statement().tokens; _i < _a.length; _i++) {
                    var s = _a[_i];
                    out += drawStatement(s);
                }
                return wrap(out);
            }
            else {
                return wrap(statement.getText());
            }
        };
        $ts_text.val(output);
        var out2 = "";
        for (var _a = 0, statements_2 = statements; _a < statements_2.length; _a++) {
            var s = statements_2[_a];
            try {
                out2 += drawStatement(s) + "<br>";
            }
            catch (e) {
                console.error(e);
            }
        }
        $structure_view.html(out2);
    });
});
